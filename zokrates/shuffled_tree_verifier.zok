from "hashes/keccak/256bit" import main as keccak;

from "EMBED" import u8_to_bits;
from "EMBED" import u8_from_bits;
from "EMBED" import u64_from_bits;
from "utils/pack/bool/pack128" import main as pack128;
from "utils/pack/bool/unpack128" import main as unpack128;

struct U256 {
    field msb;
    field lsb;
}

def U256_to_array(U256 input) -> u8[32] {
    bool[256] bits = [...unpack128(input.msb), ...unpack128(input.lsb)];
    return [
        u8_from_bits(bits[0..8]),
        u8_from_bits(bits[8..16]),
        u8_from_bits(bits[16..24]),
        u8_from_bits(bits[24..32]),
        u8_from_bits(bits[32..40]),
        u8_from_bits(bits[40..48]),
        u8_from_bits(bits[48..56]),
        u8_from_bits(bits[56..64]),
        u8_from_bits(bits[64..72]),
        u8_from_bits(bits[72..80]),
        u8_from_bits(bits[80..88]),
        u8_from_bits(bits[88..96]),
        u8_from_bits(bits[96..104]),
        u8_from_bits(bits[104..112]),
        u8_from_bits(bits[112..120]),
        u8_from_bits(bits[120..128]),
        u8_from_bits(bits[128..136]),
        u8_from_bits(bits[136..144]),
        u8_from_bits(bits[144..152]),
        u8_from_bits(bits[152..160]),
        u8_from_bits(bits[160..168]),
        u8_from_bits(bits[168..176]),
        u8_from_bits(bits[176..184]),
        u8_from_bits(bits[184..192]),
        u8_from_bits(bits[192..200]),
        u8_from_bits(bits[200..208]),
        u8_from_bits(bits[208..216]),
        u8_from_bits(bits[216..224]),
        u8_from_bits(bits[224..232]),
        u8_from_bits(bits[232..240]),
        u8_from_bits(bits[240..248]),
        u8_from_bits(bits[248..256])
    ];
}

def U256_from_array(u8[32] input) -> U256 {
    bool[256] bits = [
        ...u8_to_bits(input[0]),
        ...u8_to_bits(input[1]),
        ...u8_to_bits(input[2]),
        ...u8_to_bits(input[3]),
        ...u8_to_bits(input[4]),
        ...u8_to_bits(input[5]),
        ...u8_to_bits(input[6]),
        ...u8_to_bits(input[7]),
        ...u8_to_bits(input[8]),
        ...u8_to_bits(input[9]),
        ...u8_to_bits(input[10]),
        ...u8_to_bits(input[11]),
        ...u8_to_bits(input[12]),
        ...u8_to_bits(input[13]),
        ...u8_to_bits(input[14]),
        ...u8_to_bits(input[15]),
        ...u8_to_bits(input[16]),
        ...u8_to_bits(input[17]),
        ...u8_to_bits(input[18]),
        ...u8_to_bits(input[19]),
        ...u8_to_bits(input[20]),
        ...u8_to_bits(input[21]),
        ...u8_to_bits(input[22]),
        ...u8_to_bits(input[23]),
        ...u8_to_bits(input[24]),
        ...u8_to_bits(input[25]),
        ...u8_to_bits(input[26]),
        ...u8_to_bits(input[27]),
        ...u8_to_bits(input[28]),
        ...u8_to_bits(input[29]),
        ...u8_to_bits(input[30]),
        ...u8_to_bits(input[31])
    ];

    return U256{
        msb: pack128(bits[0..128]),
        lsb: pack128(bits[128..256])
    };
}

def order_ascending_U256(U256 a, U256 b) -> (U256, U256) {
    return if a.msb == b.msb {
        // Look at lsb to decide order.
        (a.lsb > b.lsb ? b : a, a.lsb > b.lsb ? a : b)
    } else {
        // Look at msb to decide order.
        (a.msb > b.msb ? b : a, a.msb > b.msb ? a : b)
    };
}

def check_equality_U256(U256 a, U256 b) -> bool {
    return a.msb == b.msb && a.lsb == b.lsb;
}

def hash(U256 a, U256 b) -> U256 {
    (U256, U256) digests = order_ascending_U256(a, b);
    u8[32] digest_array = keccak([...U256_to_array(digests.0), ...U256_to_array(digests.1)]);
    return U256_from_array(digest_array);
}
// on UI enter structs as {"msb": "3", "lsb": "5"}.
const u8 ONE = 1;
const u64 ALL_INDEXES_USED = -1;
const u32 LEAFS_LENGTH = 64;
const u32 INTERAL_4_LENGTH = 32;
const u32 INTERAL_3_LENGTH = 16;
const u32 INTERAL_2_LENGTH = 8;
const u32 INTERAL_1_LENGTH = 4;
const u32 INTERAL_0_LENGTH = 2;
def main(U256[LEAFS_LENGTH] leafs, U256 shuffled_root, private u32[LEAFS_LENGTH] leaf_indexing) {
    bool[64] mut indexes_used = [false;64];
    // Hash leafs to get internal layer 5.
    U256[INTERAL_4_LENGTH] mut internal_digest_4 = [U256 {msb: 0, lsb: 0};INTERAL_4_LENGTH];
    for u32 i in 0..INTERAL_4_LENGTH {
        u32 index = 2 * i;
        // Save indexes used.
        indexes_used[leaf_indexing[index]] = true;
        indexes_used[leaf_indexing[index+1]] = true;

        internal_digest_4[i] = hash(leafs[leaf_indexing[index]], leafs[leaf_indexing[index+1]]);
    }
    // Hash internal layer 4 to get internal layer 3.
    U256[INTERAL_3_LENGTH] mut internal_digest_3 = [U256 {msb: 0, lsb: 0};INTERAL_3_LENGTH];
    for u32 i in 0..INTERAL_3_LENGTH {
        u32 index = 2 * i;
        internal_digest_3[i] = hash(internal_digest_4[index], internal_digest_4[index+1]);
    }
    // Hash internal layer 3 to get internal layer 2.
    U256[INTERAL_2_LENGTH] mut internal_digest_2 = [U256 {msb: 0, lsb: 0};INTERAL_2_LENGTH];
    for u32 i in 0..INTERAL_2_LENGTH {
        u32 index = 2 * i;
        internal_digest_2[i] = hash(internal_digest_3[index], internal_digest_3[index+1]);
    }
    // Hash internal layer 2 to get internal layer 1.
    U256[INTERAL_1_LENGTH] mut internal_digest_1 = [U256 {msb: 0, lsb: 0};INTERAL_1_LENGTH];
    for u32 i in 0..INTERAL_1_LENGTH {
        u32 index = 2 * i;
        internal_digest_1[i] = hash(internal_digest_2[index], internal_digest_2[index+1]);
    }
    // Hash internal layer 1 to get internal layer 0.
    U256[INTERAL_0_LENGTH] mut internal_digest_0 = [U256 {msb: 0, lsb: 0};INTERAL_0_LENGTH];
    for u32 i in 0..INTERAL_0_LENGTH {
        u32 index = 2 * i;
        internal_digest_0[i] = hash(internal_digest_1[index], internal_digest_1[index+1]);
    }
    // Hash internal layer 0 to get root.
    U256 root = hash(internal_digest_0[0], internal_digest_0[1]);
    
    assert(check_equality_U256(root, shuffled_root));
    assert(u64_from_bits(indexes_used) == ALL_INDEXES_USED);
}